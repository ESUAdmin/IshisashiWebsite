### 最初的想法
将 8-bit RGB 转换到 16-bit YUV 后 YC 伸张/压缩，没问题；

再降到 10-bit YUV，也没问题；

但若是降到 10-bit YUV 后才 YC 伸张/压缩，那就有问题了。本来 16-bit→10-bit→16-bit 就会产生相当的错位（但不影响转回 8-bit RGB 的结果，Round 恰好没问题），这一 YC 伸张/压缩就加剧了错位（回到 8-bit RGB 就错了）。

但在 10-bit YUV 伸张/压缩之后，再压缩/伸张回来，那也没问题。

所以没事别做 YC 伸张/压缩。除非精度真的有那么高；或者能确定是从 8-bit RGB 转来的，然后还原到 RGB 再到 16-bit YUV 伸张/压缩，再降回去。当然这样也是很麻烦的。

或者从 10-bit 升到 16-bit 再伸张/压缩也可以，但降到 10-bit 就又糟了。转回 8-bit RGB 再搞，也只是偏移偏回去而已，其实也不算无损的转换。

### 分析
这种超大误差本质上就是中间精度不足导致的。

举个例子来说，一个圆的半径是 12.33 m，你说它面积多大呢？（保留两位小数）

我们知道 S=πr²，所以这个圆的面积是 152.0289π m²。

取 π≈3.14，则 S≈152.0829×3.14 m²=477.370746 m²≈477.37 m²。

但是 152.0289π≈477.61。所以就算我们结果取两位小数，中间计算取两位小数还是不够。

取 π≈3.1416，则 S≈152.0829×3.1416 m²=477.61399224 m²≈477.61 m²。这个就够了。

所以你要 YC 伸张或者压缩的话，在高精度处理过程就应该做好。不要降了精度之后才做，那样就坏事了。

另外 10-bit 都如此了，8-bit 又要成什么样子，自己去想。所以 8-bit 搞 YC 压缩简直是胡来，是我就打旗标。
